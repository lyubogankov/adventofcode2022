# std library
import itertools
import unittest
# local
import solution
from solution import CoordPair
import string_visualizer

class TestDay15(unittest.TestCase):
    EXAMPLE = 'example.txt'
    INPUT   = 'input.txt'

    def test_inputfile_parsing(self):
        expected = """....S.......................
......................S.....
...............S............
................SB..........
............................
............................
............................
..........S.......S.........
............................
............................
....B.......................
..S.........................
............................
............................
..............S.......S.....
B...........................
...........SB...............
................S..........B
....S.......................
............................
............S......S........
............................
.......................B...."""
        parsed_map = string_visualizer.visualize_sensor_beacon_map(
            sensors=solution.parse_input_file_into_sensors_and_beacons(inputfile=self.EXAMPLE)
        )
        self.assertEqual(expected, parsed_map)

    def test_exclusion_zone_calculation(self):
        expected = """..........#.................
.........###................
....S...#####...............
.......#######........S.....
......#########S............
.....###########SB..........
....#############...........
...###############..........
..#################.........
.#########S#######S#........
..#################.........
...###############..........
....B############...........
..S..###########............
......#########.............
.......#######..............
........#####.S.......S.....
B........###................
..........#SB...............
................S..........B
....S.......................
............................
............S......S........
............................
.......................B...."""
        exclusion_printout = string_visualizer.visualize_sensor_beacon_map(
            sensors=solution.parse_input_file_into_sensors_and_beacons(inputfile=self.EXAMPLE),
            show_excl_sensor_coords=[CoordPair(8, 7)]
        )
        self.assertEqual(expected, exclusion_printout)

    def test_range_unification(self):
        # case 1: partial overlap
        a = range(6)
        b = range(5, 10)
        self.assertEqual(range(10), solution.attempt_range_unification(r1=a, r2=b))
        self.assertEqual(range(10), solution.attempt_range_unification(r1=b, r2=a))
        # case 2: complete overlap
        a = range(10)
        b = range(5, 7)
        self.assertEqual(range(10), solution.attempt_range_unification(r1=a, r2=b))
        self.assertEqual(range(10), solution.attempt_range_unification(r1=b, r2=a))
        # case 3: no overlap
        self.assertEqual(None, solution.attempt_range_unification(r1=range(10), r2=range(15, 20)))

    def test_range_collection_reduction(self):
        r1 = range( 0, 10)   #..........
        r2 = range( 5, 15)   #     ..........
        r3 = range(20, 25)   #                    .....
        r4 = range(17, 23)   #                 ......
        r5 = range(13, 19)   #             ......
        # case 1: some of the ranges can be collapsed, but not all can
        with self.subTest(i="partial_reduction"):
            for permutation in itertools.permutations([r1, r2, r3]):
                self.assertEqual(
                    {range(0, 15), r3},
                    set(solution.reduce_to_min_number_of_ranges(permutation))
                )
            for permutation in itertools.permutations([r1, r2, r3, r4]):
                self.assertEqual(
                    {range(0, 15), range(17, 25)},
                    set(solution.reduce_to_min_number_of_ranges(permutation))
                )
            for permutation in itertools.permutations([r1, r3, r4, r5]):
                self.assertEqual(
                    {r1, range(13, 25)},
                    set(solution.reduce_to_min_number_of_ranges(permutation))
                )
        # case 2: none of the ranges can be collapsed
        with self.subTest(i="no_reduction"):
            for permutation in itertools.permutations([r1, r3, r5]):
                self.assertEqual(
                    {r1, r3, r5},
                    set(solution.reduce_to_min_number_of_ranges(permutation))
                )
        # case 3: all of the ranges can be collapsed
        with self.subTest(i="complete_reduction"):
            for permutation in itertools.permutations([r1, r2, r3, r4, r5]):
                self.assertEqual(
                    {range(0, 25)},
                    set(solution.reduce_to_min_number_of_ranges(permutation))
                )

    def test_part_one_row_exclusion_count(self):
        sensors = solution.parse_input_file_into_sensors_and_beacons(inputfile=self.EXAMPLE)
        count = solution.count_excluded_points_within_row(sensors, y=10)
        self.assertEqual(count, 26)

if __name__ == '__main__':
    unittest.main()